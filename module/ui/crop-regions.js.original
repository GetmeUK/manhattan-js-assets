
/**
 * A UI component that allows users to mark a region of an image to crop.
 */
export class CropRegion {

    constructor(
        container,
        orientation,
        imageURL,
        fixedAspectRatio=null
    ) {
        // The orientation of the image currently
        this._orientation = orientation

        // The crop region position and size as a rectangle
        this._region = {
            'top': 0,
            'left': 0,
            'width': 0,
            'height': 0
        }

        // The URL of the image to displayed within the crop region
        this._imageURL = imageURL

        // An optional fixed aspect ratio for the cropping region
        this._fixedAspectRatio = fixedAspectRatio

        // The the offset of crop viewport that can be cropped within relative
        // to the container.
        this._offset = [0, 0]

        // The the size of the viewport that can be cropped within
        this._viewport = [0, 0]

        // Domain for related DOM elements
        this._dom = {
            'container': null,
            'controls': null,
            'frame': null,
            'image': null,
            'region': null
        }

        // Set the container for the crop region
        this._dom.container = container
    }

    get container() {
        return this._dom.container
    }

    init() {
        const cls = this.constructor

        // Create the crop region
        this._dom.region = $.create('div', {'class': cls.css['region']})

        // Create the frame
        this._dom.frame = $.create('div', {'class': cls.css['frame']})
        this._dom.region.appendChild(this._dom.frame)

        // Create the image
        this._dom.image = $.create('div', {'class': cls.css['image']})
        this._dom.frame.appendChild(this._dom.image)

        // Create the controls
        for (let ctrl of ['c', 'n', 'ne', 'e', 'se', 's', 'sw', 'w', 'nw']) {
            let ctrlElm = $.create(
                'div',
                {
                    'class':
                        `${cls.css['control']} ${cls.css['controls'][ctrl]}`,
                    'data-mh-crop-region-control': ctrl
                }
            )
            this._dom.region.appendChild(ctrlElm)
        }

        // Set the region's background image
        this._dom.image.style.backgroundImage = `url(${this._imageURL})`

        // Add the crop region to the container
        this.container.appendChild(this._dom.region)

        // Reset the the crop region to match the current bounds and
        // orientation.
        this.reset()
    }

    get imageSize() {
        if (this._orientation === 90 || this._orientation === 270) {
            return [this._viewport[1], this._viewport[0]]
        }
        return this._viewport.slice()
    }

    /**
     * Reset the crop region to match the current bounds.
     */
    reset() {
        // Determine the intial aspect ratio (default to 1:1)
        let aspectRatio = 1
        if (this._cropAspectRatio) {
            aspectRatio = this._cropAspectRatio
        }

        // Calculate the initial crop size such that it fits within the bounds
        let width = this._viewport[0]
        let height = parseInt(this._viewport[0] / aspectRatio, 10)

        if (aspectRatio < (this._viewport[0] / this._viewport[1])) {
            width = this._viewport[1] * aspectRatio
            height = this._viewport[1]
        }

        // Calculate the initial crop position to be central to the bounds
        const left = parseInt((this._viewport[0] - width) / 2, 10)
        const top = parseInt((this._viewport[1] - height) / 2, 10)

        this.setSize(width, height)
        this.setPosition(left, top)
    }

    /**
     * Set the bounds for the crop region.
     */
    setBounds(offset, viewport) {
        this._offset = offset.slice()
        this._viewport = viewport.slice()

        // Update the background image's size to match the bounds
        this._dom.image.style.backgroundSize
            = `${this.imageSize[0]}px ${this.imageSize[1]}px`
    }

    /**
     * Set the position of the crop region.
     */
    setPosition(left, top) {

        // Set the position of the crop region (clamp the position to the crop
        // bounds).
        this._region.left = left
        // Math.max(
        //     0,
        //     Math.min(this._bounds.width - this._region.width, left)
        // )
        this._region.top = top
        // Math.max(
        //     0,
        //     Math.min(this._bounds.height - this._region.height, top)
        // )

        // Update the position of the crop region element
        this._dom.region.style.top
            = `${this._offset[1] + this._region.top}px`
        this._dom.region.style.left
            = `${this._offset[0] + this._region.left}px`

        let x = 0
        let y = 0

        if (this._orientation === 0) {
            x = this._region.left
            y = this._region.top
        }

        if (this._orientation === 90) {
            x = this._region.top
            y = (this._viewport[0] - this._region.height) - this._region.left
        }

        if (this._orientation === 180) {
            x = (this._viewport[0] - this._region.width) - this._region.left
            y = (this._viewport[1] - this._region.height) - this._region.top
        }

        if (this._orientation === 270) {
            x = (this._viewport[1] - this._region.width) - this._region.top
            y = this._region.left
        }

        this._dom.image.style.backgroundPosition = `-${x}px -${y}px`
    }

    /**
     * Set the size of the crop region.
     */
    setSize(width, height) {

        // Set the size of the crop region (clamp the size to the crop bounds)
        this._region.width = width
        // Math.max(
        //     0,
        //     Math.min(this._bounds.width - this._region.left, width)
        // )
        this._region.height = height
        // Math.max(
        //     0,
        //     Math.min(this._bounds.height - this._region.top, height)
        // )

        // Update the size of the crop region element
        this._dom.region.style.width = `${this._region.width}px`
        this._dom.region.style.height = `${this._region.height}px`

        let originX = 0;
        let originY = 0;

        if (this._orientation === 90) {
            originX = originY = this._region.width / 2.0
        }

        if (this._orientation === 180) {
            originX = this._region.width / 2.0
            originY = this._region.height / 2.0
        }

        if (this._orientation === 270) {
            originX = originY = this._region.height / 2.0
        }

        if (this._orientation === 90 || this._orientation === 270) {
            this._dom.image.style.width = `${this._region.height}px`
            this._dom.image.style.height = `${this._region.width}px`
        } else {
            this._dom.image.style.width = `${this._region.width}px`
            this._dom.image.style.height = `${this._region.height}px`
        }


        this._dom.image.style.transformOrigin = `${originX}px ${originY}px 0px`
        this._dom.image.style.transform = `rotate(${this._orientation}deg)`

    }

}


// Create a crop region for the image
// this._cropRegion = new CropRegion(
//     this._dom.table,
//     0,
//     this._imageURL,
//     this._cropAspectRatio
// )
// this._cropRegion.init()
//this._cropRegion.reset()

// @@ Need to wait a short period for the rotation then reset the crop
// and so forth.
//this._cropRegion.reset()

// @@ Set the bounds for the crop region
// this._cropRegion._orientation = this._orientation
// let viewport = [width, height]
// if (this._orientation === 90 || this._orientation === 270) {
//     viewport = [height, width]
// }
// const offset = [
//     parseInt((tableRect.width - viewport[0]) / 2.0, 10),
//     parseInt((tableRect.height - viewport[1]) / 2.0, 10)
// ]
// this._cropRegion.setBounds(offset, viewport)
